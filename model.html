<!DOCTYPE html>
<html lang="en">
    <head>
        <title>3d model</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
          <link rel="stylesheet" href="style/model.css" />

    </head>
    <body>
        <div id="info">
            3d model of criminal id :__
        <br>  <br> <br>
            <input type="File" id="file" >

            <button id="pickpoint" onclick="calcDistance()">measure </button>
            <button id="pauseani" onclick="pause()">pause/play</button>
            <button id="zoom" onclick="zoom()">zoom</button>
        </div>


        <script src="load/three.js"></script>
        <script src="load/PLYLoader.js"></script>
        <script src="load/Detector.js"></script>
        <script src="load/stats.min.js"></script>

        <script>
            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            let container, stats;
            let camera, cameraTarget, scene, renderer;
             //  var location='model/S002_001.ply';const
            let filepath;
            let clickedd=true;
            let pausee=false;
            init();
            animate();
            function init() {
              container = document.createElement( 'div' );
              document.body.appendChild( container );
              camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 15 );
              camera.position.set( 3, 0.15, 3 );
              cameraTarget = new THREE.Vector3( 0, -0.1, 0 );
              scene = new THREE.Scene();
              scene.background = new THREE.Color( 0x72645b );
              scene.fog = new THREE.Fog( 0x72645b, 2, 15 );
       
              // Ground
              const plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry( 40, 40 ),
                new THREE.MeshPhongMaterial( { color: 0x999999, specular: 0x101010 } )
              );
              plane.rotation.x = -Math.PI/2;
              plane.position.y = -0.5;
              scene.add( plane );
              plane.receiveShadow = true;
       
              // PLY file
              var loader = new THREE.PLYLoader();

              //should do a file selection method to dynamically select file i.e.filepath
              if(clickedd==1){
               getFile('model/S002_001.ply');
              }

              loader.load( filepath, function ( geometry ) {
                geometry.computeVertexNormals();
                const material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
                const mesh = new THREE.Mesh( geometry, material );
                // mesh.position.x =  -0.2;
                mesh.position.y =  0.45;
                mesh.position.z =  0;
                mesh.rotation.x = - Math.PI / 2;
                mesh.scale.multiplyScalar( 0.6 );
                mesh.castShadow = true;
                // mesh.receiveShadow = true;
                scene.add( mesh );
              } );
                // Lights
              scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );
              addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
              addShadowedLight( 0.5, 1, -1, 0xffaa00, 1 );
         
              // renderer
              renderer = new THREE.WebGLRenderer( { antialias: true } );
              renderer.setPixelRatio( window.devicePixelRatio );
              renderer.setSize( window.innerWidth, window.innerHeight );
              renderer.gammaInput = true;
              renderer.gammaOutput = true;
              renderer.shadowMap.enabled = true;
              renderer.shadowMap.renderReverseSided = false;
              container.appendChild( renderer.domElement );
              // stats
              stats = new Stats();
              container.appendChild( stats.dom );
              // resize
              window.addEventListener( 'resize', onWindowResize, false );
              document.addEventListener('mousedown', onDocumentMouseDown, false);
            }

            function calcDistance() {
              clickedd=false;
              /*
              *TODO: 
              *find the euclidean distance
              *scale it
              *display to user
              */
            }

               //method for getting x,y,z coordinates of mouse click 
            function onDocumentMouseDown( event ) {
            //  filepath='model/S001_001.ply';
              //location.reload(true);
              event.preventDefault();
              let vector = new THREE.Vector3();// 3D coordinate object 
              vector.set(
                          ( event.clientX / window.innerWidth ) * 2 - 1,
                          - ( event.clientY / window.innerHeight ) * 2 + 1,
                           0.5 );
              vector.unproject( camera );
              let raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
              let intersects = raycaster.intersectObjects(scene.children);
              if (intersects.length > 0) {
                  let selected = intersects[0];// Take the first object
                  if (!clickedd){ 
                      console.log("x:"+selected.point.x);
                      console.log("y:"+selected.point.y);
                      console.log("z:"+selected.point.z);
                  }
              }
            }

            function addShadowedLight( x, y, z, color, intensity ) {
              const directionalLight = new THREE.DirectionalLight( color, intensity );
              directionalLight.position.set( x, y, z );
              scene.add( directionalLight );
              directionalLight.castShadow = true;
              const d = 1;
              directionalLight.shadow.camera.left = -d;
              directionalLight.shadow.camera.right = d;
              directionalLight.shadow.camera.top = d;
              directionalLight.shadow.camera.bottom = -d;
              directionalLight.shadow.camera.near = 1;
              directionalLight.shadow.camera.far = 4;
              directionalLight.shadow.mapSize.width = 1024;
              directionalLight.shadow.mapSize.height = 1024;
              directionalLight.shadow.bias = -0.005;
            }

            function onWindowResize() {
              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();
              renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {
              requestAnimationFrame( animate );
              if(!pausee){
                render();
                stats.update();
             }
            }


            function render() {
              var timer = Date.now() * 0.0005;
              camera.position.x = Math.sin( timer ) * 2.5;
              camera.position.z = Math.cos( timer ) * 2.5;
              camera.lookAt( cameraTarget );
              renderer.render( scene, camera );
            }

            function getFile(x) {
              filepath=x;
            }

            function pause() {
              pausee=pausee==true?false:true;
            }

            function zoom() {
              // TODO: add logic to zoom
            }
 
        </script>
    </body>
</html>